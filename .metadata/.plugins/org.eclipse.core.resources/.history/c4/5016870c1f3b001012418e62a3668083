/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <string.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

SPI_HandleTypeDef hspi2;

UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI2_Init(void);
static void MX_USART2_UART_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */


// --- NRF24L01+ Register Definitions ---
#define NRF_REG_CONFIG      0x00
#define NRF_REG_EN_AA       0x01
#define NRF_REG_EN_RXADDR   0x02
#define NRF_REG_SETUP_AW    0x03
#define NRF_REG_SETUP_RETR  0x04
#define NRF_REG_RF_CH       0x05
#define NRF_REG_RF_SETUP    0x06
#define NRF_REG_STATUS      0x07
#define NRF_REG_RX_ADDR_P0  0x0A
#define NRF_REG_TX_ADDR     0x10
#define NRF_REG_RX_PW_P0    0x11
#define NRF_REG_FIFO_STATUS 0x17
#define NRF_REG_DYNPD       0x1C
#define NRF_REG_FEATURE     0x1D

// --- NRF24L01+ Command Definitions ---
#define NRF_CMD_R_REGISTER    0x00 // Read command and status registers. AAAAA = 5 bit register map address
#define NRF_CMD_W_REGISTER    0x20 // Write command and status registers. AAAAA = 5 bit register map address. Executable in power down or standby modes only.
#define NRF_CMD_R_RX_PAYLOAD  0x61 // Read RX-payload: 1 – 32 bytes. A read operation always starts at byte 0. Payload is deleted from FIFO after it is read. Used in RX mode.
#define NRF_CMD_W_TX_PAYLOAD  0xA0 // Write TX-payload: 1 – 32 bytes. A write operation always starts at byte 0. Used in TX payload.
#define NRF_CMD_FLUSH_TX      0xE1 // Flush TX FIFO, used in TX mode
#define NRF_CMD_FLUSH_RX      0xE2 // Flush RX FIFO, used in RX mode. Should not be executed during transmission of ACK packet.
#define NRF_CMD_R_RX_PL_WID   0x60 // Read RX-payload width for the top R_RX_PAYLOAD in the RX FIFO.
#define NRF_CMD_NOP           0xFF // No Operation. Might be used to read the STATUS register

// --- STATUS Register Bits ---
#define NRF_STATUS_RX_DR    (1<<6) // Data Ready RX FIFO interrupt
#define NRF_STATUS_TX_DS    (1<<5) // Data Sent TX FIFO interrupt
#define NRF_STATUS_MAX_RT   (1<<4) // Maximum number of TX retransmits interrupt

// --- CONFIG Register Bits ---
#define NRF_CONFIG_MASK_RX_DR  (1<<6)
#define NRF_CONFIG_MASK_TX_DS  (1<<5)
#define NRF_CONFIG_MASK_MAX_RT (1<<4)
#define NRF_CONFIG_EN_CRC      (1<<3)
#define NRF_CONFIG_CRCO        (1<<2) // CRC encoding scheme, '0':1 byte, '1':2 bytes
#define NRF_CONFIG_PWR_UP      (1<<1)
#define NRF_CONFIG_PRIM_RX     (1<<0) // RX/TX control, '1':PRX, '0':PTX


/*
 * @brief Writes data to an NRF24L01+ register.
 * @param reg_addr: The register address (5 LSBs are used).
 * @param data: Pointer to the data to write.
 * @param size: Number of bytes to write.
 * @retval HAL_StatusTypeDef from SPI transaction.
 */
HAL_StatusTypeDef nrf_write_register(uint8_t reg_addr, uint8_t* data, uint8_t size) {
    uint8_t tx_buf[size + 1];
    uint8_t rx_buf[size + 1]; // To capture status bytes clocked out
    HAL_StatusTypeDef status;

    tx_buf[0] = NRF_CMD_W_REGISTER | (reg_addr & 0x1F); // Command OR'd with register address
    memcpy(tx_buf + 1, data, size);

    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_RESET);
    status = HAL_SPI_TransmitReceive(&hspi2, tx_buf, rx_buf, size + 1, HAL_MAX_DELAY);
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_SET);

    // rx_buf[0] contains the STATUS register value at the time of command byte transmission.
    // You can print or log rx_buf[0] for debugging.
    // printf("NRF_Write: Reg 0x%02X, Status during write: 0x%02X\n", reg_addr, rx_buf[0]);

    if (status != HAL_OK) {
        printf("SPI Error in nrf_write_register: %d for reg 0x%02X\n", status, reg_addr);
    }
    return status;
}

/*
 * @brief Reads data from an NRF24L01+ register.
 * @param reg_addr: The register address (5 LSBs are used).
 * @param read_data: Pointer to a buffer to store the read data.
 * @param size: Number of bytes to read.
 * @retval HAL_StatusTypeDef from SPI transaction.
 */
HAL_StatusTypeDef nrf_read_register_multi(uint8_t reg_addr, uint8_t* read_data, uint8_t size) {
    uint8_t cmd = NRF_CMD_R_REGISTER | (reg_addr & 0x1F);
    uint8_t status_byte; // To store the status clocked out during command transmission
    HAL_StatusTypeDef status;

    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_RESET);
    // Transmit the read command, receive status byte
    status = HAL_SPI_TransmitReceive(&hspi2, &cmd, &status_byte, 1, HAL_MAX_DELAY);
    if (status == HAL_OK) {
        // Receive the register data (clocks out NOPs on MOSI if HAL_SPI_Receive requires it)
        status = HAL_SPI_Receive(&hspi2, read_data, size, HAL_MAX_DELAY);
    }
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_SET);

    // printf("NRF_Read_Multi: Reg 0x%02X, Status during read cmd: 0x%02X\n", reg_addr, status_byte);

    if (status != HAL_OK) {
        printf("SPI Error in nrf_read_register_multi: %d for reg 0x%02X\n", status, reg_addr);
    }
    return status;
}

/*
 * @brief Reads a single byte from an NRF24L01+ register.
 * @param reg_addr: The register address.
 * @retval The byte read from the register. Returns 0xFF on SPI error for simplicity.
 */
uint8_t nrf_read_single_register(uint8_t reg_addr) {
    uint8_t data_byte;
    if (nrf_read_register_multi(reg_addr, &data_byte, 1) == HAL_OK) {
        return data_byte;
    }
    return 0xFF; // Indicate error
}

/*
 * @brief Reads the NRF24L01+ STATUS register.
 * @retval The STATUS register value.
 */
uint8_t nrf_read_status_register(void) {
    uint8_t status_val;
    uint8_t nop_cmd = NRF_CMD_NOP;
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_RESET);
    HAL_SPI_TransmitReceive(&hspi2, &nop_cmd, &status_val, 1, HAL_MAX_DELAY);
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_SET);
    return status_val;
}

/*
 * @brief Clears specified IRQ flags in the STATUS register.
 * @param flags_to_clear: Bitmask of flags (NRF_STATUS_RX_DR, NRF_STATUS_TX_DS, NRF_STATUS_MAX_RT).
 */
void nrf_clear_status_flags(uint8_t flags_to_clear) {
    nrf_write_register(NRF_REG_STATUS, &flags_to_clear, 1);
}

/*
 * @brief Reads the RX payload width from the NRF24L01+.
 * @retval Payload width (1-32). Returns 0 if FIFO is empty or error.
 */
uint8_t nrf_read_rx_payload_width(void) {
    uint8_t cmd = NRF_CMD_R_RX_PL_WID;
    uint8_t width;
    uint8_t status_at_cmd_time;
    HAL_StatusTypeDef spi_status;

    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_RESET);
    // Send command, get status
    spi_status = HAL_SPI_TransmitReceive(&hspi2, &cmd, &status_at_cmd_time, 1, HAL_MAX_DELAY);
    if (spi_status == HAL_OK) {
        // Get width (send NOP to clock it out)
        uint8_t nop = NRF_CMD_NOP;
        spi_status = HAL_SPI_TransmitReceive(&hspi2, &nop, &width, 1, HAL_MAX_DELAY);
    }
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_SET);

    if (spi_status != HAL_OK) {
        printf("SPI Error in nrf_read_rx_payload_width: %d\n", spi_status);
        return 0;
    }

    // If width > 32, it indicates an error or empty FIFO.
    // A more robust check involves reading FIFO_STATUS register.
    if (width > 32) {
        // printf("NRF_Read_RX_PL_WID: Width > 32 (0x%02X), likely empty FIFO. Status was 0x%02X\n", width, status_at_cmd_time);
        return 0;
    }
    return width;
}

/*
 * @brief Reads the received payload from the RX FIFO.
 * @param payload_buffer: Buffer to store the payload.
 * @param width: The width of the payload to read (obtained from nrf_read_rx_payload_width).
 * @retval HAL_StatusTypeDef from SPI transaction.
 */
HAL_StatusTypeDef nrf_read_rx_payload(uint8_t* payload_buffer, uint8_t width) {
    uint8_t cmd = NRF_CMD_R_RX_PAYLOAD;
    uint8_t status_at_cmd_time;
    HAL_StatusTypeDef spi_status;

    if (width == 0 || width > 32) {
        printf("NRF_Read_RX_Payload: Invalid width %d\n", width);
        return HAL_ERROR;
    }

    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_RESET);
    // Send command, get status
    spi_status = HAL_SPI_TransmitReceive(&hspi2, &cmd, &status_at_cmd_time, 1, HAL_MAX_DELAY);
    if (spi_status == HAL_OK) {
        // Get payload
        spi_status = HAL_SPI_Receive(&hspi2, payload_buffer, width, HAL_MAX_DELAY);
    }
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_SET);

    // printf("NRF_Read_RX_Payload: Status during R_RX_PAYLOAD cmd: 0x%02X\n", status_at_cmd_time);
    if (spi_status != HAL_OK) {
        printf("SPI Error in nrf_read_rx_payload: %d\n", spi_status);
    }
    return spi_status;
}

/*
 * @brief Flushes the TX FIFO.
 */
void nrf_flush_tx_fifo(void) {
    uint8_t cmd = NRF_CMD_FLUSH_TX;
    uint8_t status_byte;
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_RESET);
    HAL_SPI_TransmitReceive(&hspi2, &cmd, &status_byte, 1, HAL_MAX_DELAY);
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_SET);
    // printf("NRF_Flush_TX: Status during flush: 0x%02X\n", status_byte);
}

/*
 * @brief Flushes the RX FIFO.
 */
void nrf_flush_rx_fifo(void) {
    uint8_t cmd = NRF_CMD_FLUSH_RX;
    uint8_t status_byte;
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_RESET);
    HAL_SPI_TransmitReceive(&hspi2, &cmd, &status_byte, 1, HAL_MAX_DELAY);
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_SET);
    // printf("NRF_Flush_RX: Status during flush: 0x%02X\n", status_byte);
}


// --- Slave (Transmitter) Functions ---
void init_nrf_slave(void) {
    uint8_t data_val[5];
    uint8_t addr[5] = {0x0A, 0x0B, 0x0C, 0x0D, 0x0E}; // Example address

    HAL_GPIO_WritePin(SPI_SW_CE_GPIO_Port, SPI_SW_CE_Pin, GPIO_PIN_RESET); // CE low
    HAL_Delay(100); // Allow NRF to settle

    printf("--- Initializing NRF Slave (PTX) ---\n");

    // Shared settings
    data_val[0] = 0x03; nrf_write_register(NRF_REG_SETUP_AW, data_val, 1); // 5-byte address width
    data_val[0] = 0x3C; nrf_write_register(NRF_REG_RF_CH, data_val, 1);    // Channel 60
    data_val[0] = 0x07; nrf_write_register(NRF_REG_RF_SETUP, data_val, 1); // 0dBm, 1Mbps (0x27 for 250kbps, 0x0F for 2Mbps)
                                                                          // Original was 0x27 (250kbps). Let's try 1Mbps (0x07) for robustness first.
                                                                          // Ensure master uses the same.
    // Enable Dynamic Payload Length for Pipe 0 (for ACKs if master sends ACK payloads) and globally
    data_val[0] = 0x01; nrf_write_register(NRF_REG_DYNPD, data_val, 1);    // Enable DPL on Pipe 0
    data_val[0] = 0x04; nrf_write_register(NRF_REG_FEATURE, data_val, 1);  // Enable EN_DPL feature

    // Slave (PTX) specific settings
    // CONFIG: PWR_UP, EN_CRC (2-byte), PTX mode, Unmask TX_DS, MAX_RT IRQs
    data_val[0] = NRF_CONFIG_PWR_UP | NRF_CONFIG_EN_CRC | NRF_CONFIG_CRCO | NRF_CONFIG_MASK_RX_DR;
    // data_val[0] = 0x0E; // Original: All IRQs unmasked, PTX, PWR_UP, 2-byte CRC
    nrf_write_register(NRF_REG_CONFIG, data_val, 1);

    data_val[0] = 0x01; nrf_write_register(NRF_REG_EN_AA, data_val, 1);    // Enable Auto-Ack on Pipe 0 (for receiving ACKs)
    data_val[0] = 0x01; nrf_write_register(NRF_REG_EN_RXADDR, data_val, 1); // Enable RX Pipe 0 (for receiving ACKs)
    data_val[0] = 0x1A; nrf_write_register(NRF_REG_SETUP_RETR, data_val, 1); // 500us ARD, 10 retries (adjust as needed)
                                                                            // Original was 0x0F (250us, 15 retries)

    // Set TX address and RX address for Pipe 0 (for ACKs) to the same address
    nrf_write_register(NRF_REG_TX_ADDR, addr, 5);
    nrf_write_register(NRF_REG_RX_ADDR_P0, addr, 5);

    // Clear any pending IRQ flags from startup
    nrf_clear_status_flags(NRF_STATUS_RX_DR | NRF_STATUS_TX_DS | NRF_STATUS_MAX_RT);
    nrf_flush_tx_fifo();
    nrf_flush_rx_fifo();

    HAL_Delay(5); // Allow settings to take effect

    // --- Verification Prints ---
    printf("Slave CONFIG: 0x%02X\n", nrf_read_single_register(NRF_REG_CONFIG));
    printf("Slave RF_SETUP: 0x%02X\n", nrf_read_single_register(NRF_REG_RF_SETUP));
    printf("Slave RF_CH: 0x%02X\n", nrf_read_single_register(NRF_REG_RF_CH));
    uint8_t rxtx_addr[5];
    nrf_read_register_multi(NRF_REG_TX_ADDR, rxtx_addr, 5);
    printf("Slave TX_ADDR: %02X:%02X:%02X:%02X:%02X\n", rxtx_addr[0],rxtx_addr[1],rxtx_addr[2],rxtx_addr[3],rxtx_addr[4]);
    nrf_read_register_multi(NRF_REG_RX_ADDR_P0, rxtx_addr, 5);
    printf("Slave RX_ADDR_P0: %02X:%02X:%02X:%02X:%02X\n", rxtx_addr[0],rxtx_addr[1],rxtx_addr[2],rxtx_addr[3],rxtx_addr[4]);
    printf("Slave STATUS: 0x%02X\n", nrf_read_status_register());
    printf("--- NRF Slave Initialized ---\n");
}

void transmit_nrf_payload(uint8_t size, char* data) {
    if (size == 0 || size > 32) {
        printf("Transmit_NRF: Invalid payload size %d\n", size);
        return;
    }

    uint8_t tx_payload_cmd_buf[size + 1];
    uint8_t status_byte_during_cmd; // Will hold status when W_TX_PAYLOAD is sent

    tx_payload_cmd_buf[0] = NRF_CMD_W_TX_PAYLOAD;
    memcpy(tx_payload_cmd_buf + 1, data, size);

    // Write payload to TX FIFO
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_RESET);
    HAL_SPI_TransmitReceive(&hspi2, tx_payload_cmd_buf, &status_byte_during_cmd, size + 1, HAL_MAX_DELAY);
    HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_SET);
    // printf("Transmit_NRF: Status during W_TX_PAYLOAD: 0x%02X\n", status_byte_during_cmd);

    // Pulse CE to trigger transmission
    HAL_GPIO_WritePin(SPI_SW_CE_GPIO_Port, SPI_SW_CE_Pin, GPIO_PIN_SET);
    HAL_Delay(1); // Keep CE high for at least 10us. 1ms is plenty.
                  // For very short packets and fast datarates, this could be shorter (e.g. delay_us(15))
    HAL_GPIO_WritePin(SPI_SW_CE_GPIO_Port, SPI_SW_CE_Pin, GPIO_PIN_RESET);

    // After pulsing CE, the NRF attempts transmission.
    // The IRQ pin will go low if TX_DS or MAX_RT occurs (if unmasked).
    // Or, you can poll the STATUS register.
}

// --- Master (Receiver) Functions ---
void init_nrf_master(void) {
    uint8_t data_val[5];
    uint8_t addr[5] = {0x0A, 0x0B, 0x0C, 0x0D, 0x0E}; // Must match slave's TX_ADDR

    HAL_GPIO_WritePin(SPI_SW_CE_GPIO_Port, SPI_SW_CE_Pin, GPIO_PIN_RESET); // CE low
    HAL_Delay(100);

    printf("--- Initializing NRF Master (PRX) ---\n");

    // Shared settings (MUST MATCH SLAVE)
    data_val[0] = 0x03; nrf_write_register(NRF_REG_SETUP_AW, data_val, 1); // 5-byte address width
    data_val[0] = 0x3C; nrf_write_register(NRF_REG_RF_CH, data_val, 1);    // Channel 60
    data_val[0] = 0x07; nrf_write_register(NRF_REG_RF_SETUP, data_val, 1); // 0dBm, 1Mbps (MUST MATCH SLAVE)
                                                                          // Original was 0x27 (250kbps)

    // Enable Dynamic Payload Length for Pipe 0 and globally
    data_val[0] = 0x01; nrf_write_register(NRF_REG_DYNPD, data_val, 1);   // Enable DPL on Pipe 0
    data_val[0] = 0x04; nrf_write_register(NRF_REG_FEATURE, data_val, 1); // Enable EN_DPL feature

    // Master (PRX) specific settings
    // CONFIG: PWR_UP, EN_CRC (2-byte), PRX mode, Unmask RX_DR IRQ
    data_val[0] = NRF_CONFIG_PWR_UP | NRF_CONFIG_EN_CRC | NRF_CONFIG_CRCO | NRF_CONFIG_PRIM_RX |
                  NRF_CONFIG_MASK_TX_DS | NRF_CONFIG_MASK_MAX_RT; // RX_DR IRQ enabled
    // data_val[0] = 0x0F; // Original: RX_DR IRQ enabled, TX_DS/MAX_RT masked, PRX, PWR_UP, 2-byte CRC
    nrf_write_register(NRF_REG_CONFIG, data_val, 1);

    data_val[0] = 0x01; nrf_write_register(NRF_REG_EN_AA, data_val, 1);    // Enable Auto-Ack on Pipe 0
    data_val[0] = 0x01; nrf_write_register(NRF_REG_EN_RXADDR, data_val, 1); // Enable RX Pipe 0

    // Set RX address for Pipe 0
    nrf_write_register(NRF_REG_RX_ADDR_P0, addr, 5);
    // For auto-acknowledgment, the master's TX_ADDR would be used if it needed to send a payload *with* an ACK.
    // However, standard ACKs are sent automatically using the P0 address.
    // If you plan for the master to also transmit data later, set TX_ADDR:
    // nrf_write_register(NRF_REG_TX_ADDR, master_tx_addr, 5);


    // Clear any pending IRQ flags
    nrf_clear_status_flags(NRF_STATUS_RX_DR | NRF_STATUS_TX_DS | NRF_STATUS_MAX_RT);
    nrf_flush_tx_fifo();
    nrf_flush_rx_fifo();

    HAL_Delay(5);

    // --- Verification Prints ---
    printf("Master CONFIG: 0x%02X\n", nrf_read_single_register(NRF_REG_CONFIG));
    printf("Master RF_SETUP: 0x%02X\n", nrf_read_single_register(NRF_REG_RF_SETUP));
    printf("Master RF_CH: 0x%02X\n", nrf_read_single_register(NRF_REG_RF_CH));
    uint8_t rx_p0_addr[5];
    nrf_read_register_multi(NRF_REG_RX_ADDR_P0, rx_p0_addr, 5);
    printf("Master RX_ADDR_P0: %02X:%02X:%02X:%02X:%02X\n", rx_p0_addr[0],rx_p0_addr[1],rx_p0_addr[2],rx_p0_addr[3],rx_p0_addr[4]);
    printf("Master STATUS: 0x%02X\n", nrf_read_status_register());
    printf("--- NRF Master Initialized ---\n");

    // IMPORTANT: After initialization, put master in RX mode by setting CE HIGH
    HAL_GPIO_WritePin(SPI_SW_CE_GPIO_Port, SPI_SW_CE_Pin, GPIO_PIN_SET);
    printf("Master CE is HIGH, listening for packets.\n");
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SPI2_Init();
  MX_USART2_UART_Init();
  /* USER CODE BEGIN 2 */
  HAL_Delay(500);
  init_nrf_slave();
  uint32_t tx_count = 0;


  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {

	  HAL_Delay(1000); // Send a message every second, or on button press

	  // Example: Transmit on button press (replace with your GPIO_input_Pin logic)
	  // if(HAL_GPIO_ReadPin(GPIO_INPUT_GPIO_Port, GPIO_INPUT_PIN) == GPIO_PIN_SET) {

	  char message[32];
	  sprintf(message, "Slave Msg %lu", tx_count++);
	  printf("Slave: Transmitting: \"%s\"\n", message);
	  transmit_nrf_payload(strlen(message), message);

	  // Check status after attempting transmission
	  HAL_Delay(20); // Give time for ACK or MAX_RT
	  uint8_t slave_status = nrf_read_status_register();
	  printf("Slave: STATUS after TX attempt: 0x%02X\n", slave_status);

	  if (slave_status & NRF_STATUS_TX_DS) {
		  printf("Slave: TX_DS set. Transmission successful, ACK likely received.\n");
		  nrf_clear_status_flags(NRF_STATUS_TX_DS); // Clear TX_DS
	  }
	  if (slave_status & NRF_STATUS_MAX_RT) {
		  printf("Slave: MAX_RT set. Max retries reached, ACK not received.\n");
		  nrf_clear_status_flags(NRF_STATUS_MAX_RT); // Clear MAX_RT
		  nrf_flush_tx_fifo(); // Flush TX FIFO as packet was not delivered
		  printf("Slave: TX FIFO flushed due to MAX_RT.\n");
	  }
	          // } // end if button press
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE2);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief SPI2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI2_Init(void)
{

  /* USER CODE BEGIN SPI2_Init 0 */

  /* USER CODE END SPI2_Init 0 */

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */
  /* SPI2 parameter configuration*/
  hspi2.Instance = SPI2;
  hspi2.Init.Mode = SPI_MODE_MASTER;
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi2.Init.NSS = SPI_NSS_SOFT;
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi2.Init.CRCPolynomial = 7;
  hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI2_Init 2 */

  /* USER CODE END SPI2_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(SPI_SW_CE_GPIO_Port, SPI_SW_CE_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(SPI_SW_CSN_GPIO_Port, SPI_SW_CSN_Pin, GPIO_PIN_SET);

  /*Configure GPIO pins : SPI_SW_CE_Pin SPI_SW_CSN_Pin */
  GPIO_InitStruct.Pin = SPI_SW_CE_Pin|SPI_SW_CSN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : GPIO_input_Pin */
  GPIO_InitStruct.Pin = GPIO_input_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIO_input_GPIO_Port, &GPIO_InitStruct);

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
int _write(int file, char *ptr, int len)
{
  // We only care about stdout (1) and stderr (2)
  // For other file descriptors, you might want to return -1 or handle them differently.
  if (file == 1 || file == 2) {
    // Transmit the data through UART2
    // HAL_MAX_DELAY means the function will block until transmission is complete or timeout occurs.
    // You can adjust the timeout value as needed.
    // For non-blocking, you would need to manage the transmission buffer and use interrupts or DMA.
    if (HAL_UART_Transmit(&huart2, (uint8_t *)ptr, len, HAL_MAX_DELAY) == HAL_OK) {
      return len; // Return the number of characters written
    } else {
      return -1; // Or EIO, if you include errno.h and want to set errno
    }
  }
  // For other file descriptors, return an error or handle as appropriate.
  // For example, you could implement a basic file system or return -1.
  // return -1; // Or handle other file descriptors
  return len; // If you want to pretend other files "worked" without actual output
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
